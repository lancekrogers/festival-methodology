package template

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestIntegration_FestivalCreation simulates creating a complete festival
func TestIntegration_FestivalCreation(t *testing.T) {
	// Setup: Create template directory structure
	tmpDir := t.TempDir()
	templateDir := filepath.Join(tmpDir, "templates")
	outputDir := filepath.Join(tmpDir, "my-festival")

	// Create template files (only festival-level templates, not phase templates)
	templates := map[string]string{
		"FESTIVAL_OVERVIEW.md": `---
template_id: FESTIVAL_OVERVIEW
template_version: 1.0.0
required_variables:
  - festival_name
  - festival_goal
  - created_date
optional_variables:
  - owner
---
# Festival Overview: {{.festival_name}}

**Created:** {{.created_date}}
**Owner:** {{.owner | default "TBD"}}
**Status:** Planning

## Project Goal

**Primary Objective:** {{.festival_goal}}

[GUIDANCE: Expand on the goal above. What specific outcomes define success?]

## Tech Stack

[GUIDANCE: List technologies by category:
- **Languages:** Go, TypeScript, etc.
- **Frameworks:** BubbleTea, Next.js, etc.
]

## Success Criteria

[FILL: Add success criteria that define when this festival is complete]

---

_Generated by fest CLI v{{.fest_version}}_`,

		"README.md": `# {{.festival_name}}

Created: {{.created_date}}

[GUIDANCE: Add festival overview and getting started instructions]`,
	}

	// Create template files
	for path, content := range templates {
		fullPath := filepath.Join(templateDir, path)
		err := os.MkdirAll(filepath.Dir(fullPath), 0755)
		require.NoError(t, err)
		err = os.WriteFile(fullPath, []byte(content), 0644)
		require.NoError(t, err)
	}

	// Step 1: Build context for festival creation
	ctx := NewContextBuilder().
		BuildForFestival("auth-system-enhancement", "Implement OAuth authentication")

	// Add owner
	ctx.User["owner"] = "Lance Rogers"

	// Step 2: Render templates
	manager := NewManager()
	err := manager.RenderDirectory(templateDir, outputDir, ctx)
	require.NoError(t, err)

	// Step 3: Verify outputs
	overviewPath := filepath.Join(outputDir, "FESTIVAL_OVERVIEW.md")
	require.FileExists(t, overviewPath)

	content, err := os.ReadFile(overviewPath)
	require.NoError(t, err)
	contentStr := string(content)

	// Verify variable substitution
	assert.Contains(t, contentStr, "# Festival Overview: auth-system-enhancement")
	assert.Contains(t, contentStr, "**Primary Objective:** Implement OAuth authentication")
	assert.Contains(t, contentStr, "**Owner:** Lance Rogers")

	// Verify automatic variables
	assert.Contains(t, contentStr, "**Created:** 202") // Should have current date
	assert.Contains(t, contentStr, "_Generated by fest CLI v2.0.0-dev_")

	// Verify [GUIDANCE] markers preserved
	assert.Contains(t, contentStr, "[GUIDANCE: Expand on the goal above")
	assert.Contains(t, contentStr, "[FILL: Add success criteria")

	// Verify no unrendered variables
	assert.NotContains(t, contentStr, "{{")
	assert.NotContains(t, contentStr, "}}")

	t.Logf("Successfully rendered festival to: %s", outputDir)
	t.Logf("Overview content length: %d bytes", len(content))
}

// TestIntegration_PhaseCreation simulates adding a phase to an existing festival
func TestIntegration_PhaseCreation(t *testing.T) {
	tmpDir := t.TempDir()
	templatePath := filepath.Join(tmpDir, "PHASE_GOAL.md")
	outputPath := filepath.Join(tmpDir, "001_PLANNING", "PHASE_GOAL.md")

	// Create phase template
	template := `---
template_id: PHASE_GOAL
required_variables:
  - phase_id
  - phase_name
---
# Phase: {{.phase_id}}

## Objective

Define and document requirements for {{.festival_name}}

[FILL: Specific objectives for {{.phase_name}} phase]

## Timeline

Phase {{.phase_number}} of the festival

[FILL: Estimated timeline]`

	err := os.WriteFile(templatePath, []byte(template), 0644)
	require.NoError(t, err)

	// Build context for phase
	ctx := NewContextBuilder().BuildForPhase("auth-system-enhancement", 1, "PLANNING")

	// Render phase
	manager := NewManager()
	err = manager.RenderFileToFile(templatePath, outputPath, ctx)
	require.NoError(t, err)

	// Verify output
	content, err := os.ReadFile(outputPath)
	require.NoError(t, err)
	contentStr := string(content)

	assert.Contains(t, contentStr, "# Phase: 001_PLANNING")
	assert.Contains(t, contentStr, "Phase 1 of the festival")
	assert.Contains(t, contentStr, "PLANNING phase")
	assert.Contains(t, contentStr, "[FILL: Specific objectives")
}

// TestIntegration_ComplexTemplate tests Sprig functions and complex templates
func TestIntegration_ComplexTemplate(t *testing.T) {
	manager := NewManager()

	template := `# Festival: {{.name | upper}}

Created: {{.created_date | default "Unknown"}}

## Tags
{{range .tags}}
- {{.}}
{{end}}

## Summary

This festival has {{len .tags}} tags.

[GUIDANCE: Add more details about {{.name}}]`

	ctx := NewContextBuilder().
		WithUser("name", "my-festival").
		WithUser("tags", []string{"auth", "security", "api"}).
		Build()

	output, err := manager.RenderString(template, ctx)
	require.NoError(t, err)

	// Verify Sprig function (upper)
	assert.Contains(t, output, "# Festival: MY-FESTIVAL")

	// Verify iteration
	assert.Contains(t, output, "- auth")
	assert.Contains(t, output, "- security")
	assert.Contains(t, output, "- api")

	// Verify Sprig function (len)
	assert.Contains(t, output, "This festival has 3 tags")

	// Verify [GUIDANCE] preserved
	assert.Contains(t, output, "[GUIDANCE: Add more details about")
}

// TestIntegration_MissingRequiredVariable tests validation
func TestIntegration_MissingRequiredVariable(t *testing.T) {
	tmpDir := t.TempDir()
	templatePath := filepath.Join(tmpDir, "test.md")

	template := `---
required_variables:
  - name
  - goal
  - description
---
# {{.name}}

Goal: {{.goal}}
Description: {{.description}}`

	err := os.WriteFile(templatePath, []byte(template), 0644)
	require.NoError(t, err)

	// Create context missing 'description'
	ctx := NewContextBuilder().
		WithUser("name", "test").
		WithUser("goal", "test goal").
		Build()

	// Should fail validation
	manager := NewManager()
	_, err = manager.RenderFile(templatePath, ctx)

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "validation failed")
	assert.Contains(t, err.Error(), "description")
}

// TestIntegration_RealWorldScenario simulates real usage
func TestIntegration_RealWorldScenario(t *testing.T) {
	// Step 1: User runs `fest init auth-enhancement`
	festivalName := "auth-enhancement"
	festivalGoal := "Add OAuth 2.0 authentication to the API"

	// Step 2: fest CLI collects data (simulated)
	userData := map[string]interface{}{
		"festival_name": festivalName,
		"festival_goal": festivalGoal,
		"owner":         "Development Team",
		"tags":          []string{"authentication", "security", "api"},
		"tech_stack":    "Go, PostgreSQL, Redis",
	}

	// Step 3: Build context
	ctx := NewContextBuilder().WithUserMap(userData).Build()

	// Step 4: Create simple overview template
	template := `# Festival: {{.festival_name}}

## Goal
{{.festival_goal}}

## Team
Owner: {{.owner}}

## Technology
{{.tech_stack}}

## Tags
{{range .tags}}- {{.}}
{{end}}

## Status
Created: {{.created_date}}

[GUIDANCE: Add implementation details below]

## Implementation Plan

[FILL: Define phases and sequences]`

	// Step 5: Render
	manager := NewManager()
	output, err := manager.RenderString(template, ctx)
	require.NoError(t, err)

	// Step 6: Verify realistic output
	assert.Contains(t, output, "# Festival: auth-enhancement")
	assert.Contains(t, output, "Add OAuth 2.0 authentication")
	assert.Contains(t, output, "Owner: Development Team")
	assert.Contains(t, output, "Go, PostgreSQL, Redis")
	assert.Contains(t, output, "- authentication")
	assert.Contains(t, output, "- security")
	assert.Contains(t, output, "- api")
	assert.Contains(t, output, "Created: 202") // Current date
	assert.Contains(t, output, "[GUIDANCE: Add implementation details")
	assert.Contains(t, output, "[FILL: Define phases")

	// No unrendered variables
	assert.NotContains(t, output, "{{")

	t.Logf("Successfully created festival overview:\n%s", output)
}
