Node Reference System
=====================

Overview
--------

Node references provide unique identifiers for tracing code changes back to
specific festival tasks. When agents include node references in TODO comments,
it creates a clear audit trail connecting code to planning documents.

Format Specification
--------------------

Node references follow this format:

  <FestivalID>:P<Phase>.S<Sequence>.T<Task>

Components:

  FestivalID   2 uppercase letters + 4 digits    GU0001
  Phase        P + 3 zero-padded digits          P002
  Sequence     S + 2 zero-padded digits          S01
  Task         T + 2 zero-padded digits          T03

Full example: GU0001:P002.S01.T03
  - Festival ID: GU0001 (Guild project, festival #1)
  - Phase 2
  - Sequence 1
  - Task 3

Usage Patterns
--------------

TODO Comments:

  Include node references in TODO comments to link code changes to festival tasks:

    // TODO(GU0001:P002.S01.T03): Implement error handling for edge cases
    func ProcessData(ctx context.Context, data []byte) error {
        // Implementation
    }

Code Comments:

  Reference the task that introduced or modified code:

    // Added as part of GU0001:P002.S01.T03
    type DataProcessor struct {
        // ...
    }

Test File Headers:

  Include references in test file headers:

    // Package validation_test contains tests for input validation
    // Added as part of GU0001:P002.S01.T01 (test-first development)
    package validation_test

Where to Find Your Current Reference
------------------------------------

Use these fest commands to see your current node reference:

  fest show        Displays ID and current node reference
  fest context     JSON output includes festival_id and current_ref fields
  fest validate    Shows context header with node reference and TODO example

Example output from fest show:

  Festival: my-project_GU0001
    ID: GU0001
    Status: active
    Progress: 45.0%

Benefits
--------

1. Traceability
   Connect code changes directly to planning documents. When reviewing code,
   you can trace any change back to its originating task.

2. Context
   Future developers can find the "why" behind code decisions by looking
   up the referenced task's objective and deliverables.

3. Searchability
   Grep for node references to find all related changes:

     grep -r "GU0001:P002" ./src

4. Accountability
   Clear record of what was done during each task, making code review
   and audits straightforward.

Searching for Node References
-----------------------------

Find all references to a specific festival:

  grep -r "GU0001:" ./src

Find all references to a specific phase:

  grep -r "GU0001:P002" ./src

Find all references to a specific task:

  grep -r "GU0001:P002.S01.T03" ./src

Regex pattern for matching node references:

  [A-Z]{2,4}\d{4}:P\d{3}\.S\d{2}\.T\d{2}

Legacy Festivals
----------------

Festivals created before the node ID system won't have IDs. You can:

1. Continue using them without IDs (backwards compatible)
2. Run 'fest migrate' to add IDs to existing festivals (future feature)

When working with legacy festivals, fest commands will show:

  ID: (no ID - legacy festival)

Quick Reference
---------------

  View current ID:       fest show
  JSON with ID:          fest context --json
  ID in validation:      fest validate

  Example TODO:          // TODO(GU0001:P002.S01.T03): Description
  Example comment:       // Added as part of GU0001:P002.S01.T03

